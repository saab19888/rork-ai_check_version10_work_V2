import { AnalysisRequest, AnalysisResult } from "@/types";
import { mockAnalysisResults } from "@/mocks/analysis";
import { db } from "./firebase";
import { collection, addDoc, query, where, orderBy, getDocs, doc, getDoc, deleteDoc, updateDoc } from "firebase/firestore";

// Simulate API delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// ChatGPT API configuration
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";

// AI detection function using ChatGPT
export const analyzeText = async (request: AnalysisRequest): Promise<AnalysisResult> => {
  const { text, fileName } = request;
  
  try {
    // Check if API key is available
    if (!OPENAI_API_KEY) {

      return await fallbackAnalysis(request);
    }
    
    // Prepare the prompt for ChatGPT
    const prompt = `You are an AI detection expert. Analyze the following text and determine if it was written by AI or a human. 

Provide your response in the following JSON format:
{
  "classification": "human" | "ai" | "mixed",
  "confidenceScore": number (0-100),
  "reasoning": "detailed explanation of your analysis",
  "suspiciousPatterns": ["pattern1", "pattern2"],
  "suggestions": ["suggestion1", "suggestion2"]
}

Consider these factors:
- Writing style and tone consistency
- Vocabulary complexity and variation
- Sentence structure patterns
- Personal anecdotes or experiences
- Emotional expressions
- Grammatical perfection vs natural imperfections
- Technical terminology usage
- Repetitive phrasing

Text to analyze:
"${text.replace(/"/g, '\\"')}"`;

    const response = await fetch(OPENAI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are an expert AI detection system. Analyze text and provide detailed, accurate assessments of whether content was generated by AI or written by humans.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 1000
      })
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    const aiResponse = data.choices[0]?.message?.content;
    
    if (!aiResponse) {
      throw new Error('No response from OpenAI API');
    }

    // Parse the JSON response from ChatGPT
    let analysisData;
    try {
      // Extract JSON from the response (in case there's extra text)
      const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        analysisData = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error('No JSON found in response');
      }
    } catch (parseError) {

      // Fallback to basic analysis
      return await fallbackAnalysis(request);
    }

    // Generate highlights based on suspicious patterns
    const highlights: AnalysisResult["highlights"] = [];
    if (analysisData.suspiciousPatterns && Array.isArray(analysisData.suspiciousPatterns)) {
      analysisData.suspiciousPatterns.forEach((pattern: string) => {
        const lowerText = text.toLowerCase();
        const lowerPattern = pattern.toLowerCase();
        let index = lowerText.indexOf(lowerPattern);
        
        while (index !== -1) {
          highlights.push({
            start: index,
            end: index + pattern.length,
            reason: `Suspicious pattern detected: "${pattern}"`,
          });
          index = lowerText.indexOf(lowerPattern, index + 1);
        }
      });
    }

    // Create the analysis result
    const result: AnalysisResult = {
      id: `analysis-${Date.now()}`,
      text,
      classification: analysisData.classification || 'mixed',
      confidenceScore: Math.min(Math.max(analysisData.confidenceScore || 50, 0), 100),
      highlights,
      suggestions: analysisData.suggestions || ['Analysis completed using AI detection'],
      createdAt: new Date().toISOString(),
    };

    return result;
    
  } catch (error) {

    // Fallback to basic pattern matching if API fails
    return await fallbackAnalysis(request);
  }
};

// Fallback analysis function (original logic)
const fallbackAnalysis = async (request: AnalysisRequest): Promise<AnalysisResult> => {
  await delay(1000);
  
  const { text, fileName } = request;
  const textSample = text.toLowerCase();
  
  let classification: "human" | "ai" | "mixed";
  let confidenceScore: number;
  let highlights: AnalysisResult["highlights"] = [];
  let suggestions: string[] = [];
  
  // Simple pattern matching for demo purposes
  const aiPatterns = [
    "language model", "ai", "artificial intelligence", "gpt", "chatgpt", 
    "machine learning", "algorithm", "optimized", "generated", "furthermore",
    "moreover", "in conclusion", "it is important to note", "comprehensive"
  ];
  
  const humanPatterns = [
    "i think", "i feel", "in my opinion", "i believe", "personally", 
    "i remember", "i forgot", "i'm not sure", "i guess", "kinda", "sorta",
    "um", "uh", "like", "you know", "i mean"
  ];
  
  // Count matches
  const aiMatches = aiPatterns.filter(pattern => textSample.includes(pattern)).length;
  const humanMatches = humanPatterns.filter(pattern => textSample.includes(pattern)).length;
  
  // Determine classification based on pattern matches
  if (aiMatches > 0 && humanMatches === 0) {
    classification = "ai";
    confidenceScore = Math.min(60 + aiMatches * 10, 95);
    
    // Find AI pattern locations for highlights
    aiPatterns.forEach(pattern => {
      let index = textSample.indexOf(pattern);
      while (index !== -1) {
        highlights.push({
          start: index,
          end: index + pattern.length,
          reason: `Contains AI-typical term: "${pattern}"`,
        });
        index = textSample.indexOf(pattern, index + 1);
      }
    });
    
    suggestions = [
      "Add personal anecdotes or experiences",
      "Include more informal language or colloquialisms",
      "Vary sentence structure and length",
      "Add some imperfections or tangential thoughts",
      "Note: This is a fallback analysis - API unavailable"
    ];
  } else if (humanMatches > 0 && aiMatches === 0) {
    classification = "human";
    confidenceScore = Math.min(65 + humanMatches * 8, 95);
    
    // Find human pattern locations for highlights
    humanPatterns.forEach(pattern => {
      let index = textSample.indexOf(pattern);
      while (index !== -1) {
        highlights.push({
          start: index,
          end: index + pattern.length,
          reason: `Contains human-typical expression: "${pattern}"`,
        });
        index = textSample.indexOf(pattern, index + 1);
      }
    });
    
    suggestions = [
      "No significant AI patterns detected",
      "Contains natural language variations",
      "Includes personal context and perspective",
      "Note: This is a fallback analysis - API unavailable"
    ];
  } else if (aiMatches > 0 && humanMatches > 0) {
    classification = "mixed";
    const ratio = aiMatches / (aiMatches + humanMatches);
    confidenceScore = 50 + Math.floor(ratio * 30);
    
    // Find both pattern types for highlights
    [...aiPatterns, ...humanPatterns].forEach(pattern => {
      let index = textSample.indexOf(pattern);
      while (index !== -1) {
        const isAiPattern = aiPatterns.includes(pattern);
        highlights.push({
          start: index,
          end: index + pattern.length,
          reason: isAiPattern 
            ? `Contains AI-typical term: "${pattern}"`
            : `Contains human-typical expression: "${pattern}"`,
        });
        index = textSample.indexOf(pattern, index + 1);
      }
    });
    
    suggestions = [
      "Contains both AI and human writing patterns",
      "Consider reviewing AI-like sections for more personal voice",
      "Text may have been edited or augmented after AI generation",
      "Note: This is a fallback analysis - API unavailable"
    ];
  } else {
    // Not enough clear patterns to determine
    classification = Math.random() > 0.5 ? "human" : "ai";
    confidenceScore = 30 + Math.floor(Math.random() * 30);
    
    suggestions = [
      "Text lacks strong indicators of either AI or human authorship",
      "Consider adding more distinctive writing elements",
      "Analysis confidence is low due to neutral writing style",
      "Note: This is a fallback analysis - API unavailable"
    ];
  }
  
  // Create a new analysis result
  const result: AnalysisResult = {
    id: `analysis-${Date.now()}`,
    text,
    classification,
    confidenceScore,
    highlights,
    suggestions,
    createdAt: new Date().toISOString(),
  };
  
  return result;
};

export const getAnalysisHistory = async (userId: string): Promise<AnalysisResult[]> => {
  try {
    if (!db) {
      return [];
    }
    
    if (!userId) {
      return [];
    }
    
    const analysisCollection = collection(db, 'analyses');
    const q = query(
      analysisCollection,
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    const results: AnalysisResult[] = [];
    
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      
      // STRICT FILTERING: Only include analyses that have a userId AND it matches the requested user
      if (data.userId && data.userId === userId) {
        results.push({
          id: doc.id,
          text: data.text,
          classification: data.classification,
          confidenceScore: data.confidenceScore,
          highlights: data.highlights || [],
          suggestions: data.suggestions || [],
          createdAt: data.createdAt,
        });
      }
    });
    
    return results;
  } catch (error) {
    // Return empty array instead of mock data to avoid confusion
    return [];
  }
};

export const getAnalysisById = async (id: string, userId?: string): Promise<AnalysisResult | undefined> => {
  try {
    if (!db) {
      return undefined;
    }

    const docRef = doc(db, 'analyses', id);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      const data = docSnap.data();
      
      // If userId is provided, verify the analysis belongs to the user
      if (userId && data.userId !== userId) {
        return undefined;
      }
      
      return {
        id: docSnap.id,
        text: data.text,
        classification: data.classification,
        confidenceScore: data.confidenceScore,
        highlights: data.highlights || [],
        suggestions: data.suggestions || [],
        createdAt: data.createdAt,
      };
    }
    
    return undefined;
  } catch (error) {
    return undefined;
  }
};

// Save analysis result to Firestore
export const saveAnalysisResult = async (result: AnalysisResult, userId: string): Promise<string> => {
  try {
    if (!db) {
      throw new Error('Database not available');
    }
    
    if (!userId) {
      throw new Error('User ID is required');
    }

    const analysisData = {
      userId, // This ensures data isolation - each user only sees their own analyses
      text: result.text,
      classification: result.classification,
      confidenceScore: result.confidenceScore,
      highlights: result.highlights,
      suggestions: result.suggestions,
      createdAt: result.createdAt,
    };
    
    const docRef = await addDoc(collection(db, 'analyses'), analysisData);
    return docRef.id;
  } catch (error) {
    throw error; // Re-throw to let the caller handle it
  }
};

// Get user's analysis count (for usage tracking)
export const getUserAnalysisCount = async (userId: string): Promise<number> => {
  try {
    if (!db) {
      return 0;
    }
    
    if (!userId) {
      return 0;
    }
    
    const analysisCollection = collection(db, 'analyses');
    const q = query(
      analysisCollection,
      where('userId', '==', userId)
    );
    
    const querySnapshot = await getDocs(q);
    const count = querySnapshot.size;
    
    return count;
  } catch (error) {
    return 0;
  }
};

// Delete a specific analysis (user can only delete their own)
export const deleteAnalysis = async (analysisId: string, userId: string): Promise<boolean> => {
  try {
    if (!db) {
      return false;
    }
    
    if (!userId) {
      return false;
    }
    
    // First verify the analysis belongs to the user
    const docRef = doc(db, 'analyses', analysisId);
    const docSnap = await getDoc(docRef);
    
    if (!docSnap.exists()) {
      return false;
    }
    
    const data = docSnap.data();
    if (data.userId !== userId) {
      return false;
    }
    
    // Delete the document
    await deleteDoc(docRef);
    return true;
  } catch (error) {
    return false;
  }
};

